# IO モナド

(仮の下書き)

IOモナド自体、特別なSTモナドと捉える考えを推し進めると、IO 関手 `IO = (ST RealWorld)` によって Haskell の任意の型 `a` から構成される
「`RealWorld` 型の状態へ作用させた際に型 `a` の値を生成する状態トランスフォーマ型 `(ST RealWorld a)`」の値である状態トランスフォーマたちを、
その IO 関手とともにモナドの構造を成すことができる2つの自然変換を指定することによって、「モナド」という一般的な枠組みから状態トランスフォーマを取り扱えるようにしたものと捉えることもできる。

ポイントは Haskell において、「型 `a` から型 `(IO a)` の構成 `IO`」に対して `return` と `(>>=)` という関数がそれぞれ **公理的に** 定義されているという点にある。
これはモナドの節での説明からわかるように、間接的には、関手 IO と、さらにそれと共にモナドの構造をなす自然変換 unit, join からなる一つのモナド <IO,unit,join> を公理的に定義していることを意味する。

`(return x)::IO X` というのは、状態は変化させず、値 `x` をただ生じさせるだけの状態トランスフォーマであるわけであるが、
重要なこととして、`RealWorld` 型というのは便宜的な記号であり、`RealWorld` 型の初期状態をマニュアル的に Haskell コードの中で指定して、その状態変化を Haskell それ自体が実演することは現実問題としてできない。
つまりこの `(IO X)` 型の要素について、状態に作用することで生じる値というのは、一般的に Haskell が知ることはできないことになる。

そもそもとして、状態に作用して初めて値を生成することになっているのだから、たとえそのような、`return` を使ってはじき出した自明な状態トランスフォーマであったとしても、
繰り返しになるがHaskellのコードの中では、初期状態を与え、その与えられた状態にそのトランスフォーマを作用させた先に生じることになる値を取得する術がないため、
そういった自明なトランスフォーマに対してさえも、実際に値 `x` を生じさせている様子を実際に見ることはできないことにもなる。
(ちなみにそういった術がないことで参照透過性が保障されているというわけでもなく、仮に runState':(IO a)→(RealWorld→(a,RealWorld)) なるものの存在を想定したとしても参照透過性は依然壊れないだろう)

とはいえ、「`(return x)`」や「状態変数を使いたいがためにやむを得ず IO を使っているが、出力として得る値は入力のみで決まっている」というような、状態に作用させたときに生じる値が分かりきっている
状況下にある状態トランスフォーマに対して、そのわかりきった値を対応させる操作があると便利である。

そういったことを実現する一つの手段としてまず `unsafePerformIO` というものが存在するが、これは文字通り安全ではなく、プログラムの動作に不具合の出ないように気を付けた適切な使用法が
わかっている場合を除いては、むやみに使うべきものではない。



## サンプルコードの実行結果
