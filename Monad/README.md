# モナド

(仮の下書き)

まず圏論的にモナド (monad) とは、`;` を射の水平合成、`*` を射の垂直合成としたとき

```
(join;T)*join = (T;join)*join
(unit;T)*join = (T;unit)*join = T
```

を満たす

- 関手 `T:C->C:T=>T`
- 自然変換 `unit:C->C:C=>T`
- 自然変換 `join:C->C:(T;T)=>T`

の3つの射からなる構造 <T, unit, join> ではあるが、Haskell ではモナドは次のような実用により適した形で与えられる。

- 任意の型 `a` からある型 `a'=T(a)` の構成 `T`
- 関数 `return : a -> (T a)`
- 関数 `(>>=) : T a -> (a -> T b) -> T b`

まず気付く点として、この定義自体は T が関手であることを明示的にいっていない。
しかしこれについては、任意の `z:(T a), f:X -> (T b)` について、`(z >>= f)` が、
圏論的には `z;((f;T)*(Y;join))` という定義になることからも

`fmap = \f -> (>>= return . f)`

として、`return` と `(>>=)` から 構成 `T` が関手であることが常に誘導される。また、2つの自然変換の成分 `unit_a = (a;unit), join_a = (a;join)` については

```
unit_a = return :: (a -> T a)
join_a = (>>= id) :: (T (T a) -> T a)
```

といった対応関係になっている。

より圏論ライクに `X:1->C:X=>X, Y:1->C:Y=>Y, h:1->C:X=>Y` として `f = h*(Y;unit)` を `(>>=f)` の定義にそのまま代入して展開したとしても

```
(>>=f)
=(f;T)*(Y;join)
=((h*(Y;unit));T)*(Y;join)
=((h*(Y;unit));(T*T))*(Y;join)
=((h;T)*((Y;unit);T))*(Y;join)
=(h;T)*(Y;unit;T)*(Y;join)
=(h;T)*((Y;(unit;T))*(Y;join))
=(h;T)*((Y*Y);((unit;T)*join))
=(h;T)*(Y;((unit;T)*join))

モナド則 (unit;T)*join = T より

=(h;T)*(Y;T)
=h;T
```

というように、同様に h と 関手 T の水平合成 (h;T) =: T(h) = `(fmap h) :: T X -> T Y` が得られ、また `(>>= id)`についても

```
(>>= id)
=(>>= (X;T))
=((X;T);T)*(X;join)
=X;join
```

というように、`join` の成分 `join_X := (X;join)` が得られる。

## モナドの例

まず簡単な例として、Maybe モナドを考える。
C を終対象と全ての有限余積を持つ圏、+:CxC->C:+=>+ を対象の対からそれらの余積を構成する関手、
1_C:1->C:1_C=>1_C を C の終対象とした時、Maybe モナドの構成要素となる関手 Maybe:C->C:Maybe=>Maybe というのは数学的には、
C の対象 X から X に新たな一つの値 Nothing (:= inj2:1->C:1_C=>X+1_C) を組み込んだ対象 X+1 を構成する関手 ((-)+1):=<C,!;1_C>;+ に相当する。

## サンプルコードの実行結果
